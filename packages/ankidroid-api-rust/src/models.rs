//! Data models for AnkiDroid entities
//!
//! This module provides Rust representations of AnkiDroid data structures including
//! notes, cards, decks, and models. All structures include serde support for 
//! serialization and deserialization.

use serde::{Deserialize, Serialize};

/// Represents a note in AnkiDroid
///
/// Notes are the fundamental unit of content in Anki, containing fields and tags.
/// Each note belongs to a note type (model) and can generate one or more cards.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Note {
    /// Unique identifier for the note
    pub id: i64,
    /// Global unique identifier
    pub guid: String,
    /// Model ID (note type ID) that this note belongs to
    pub mid: i64,
    /// Modification time as Unix timestamp
    pub mod_: i64,
    /// Update sequence number for sync
    pub usn: i32,
    /// Tags associated with this note
    pub tags: Vec<String>,
    /// Field values for this note
    pub fields: Vec<String>,
    /// Sort field value (first field by default)
    pub sfld: String,
    /// Checksum for duplicate detection
    pub csum: i64,
    /// Bitfield for various flags
    pub flags: i32,
    /// Additional data (usually empty)
    pub data: String,
}

impl Note {
    /// Create a new note with default values
    pub fn new(mid: i64, fields: Vec<String>) -> Self {
        let sfld = fields.first().cloned().unwrap_or_default();
        Self {
            id: 0, // Will be assigned by AnkiDroid
            guid: String::new(), // Will be generated by AnkiDroid
            mid,
            mod_: 0, // Will be set by AnkiDroid
            usn: -1, // Indicates new/modified
            tags: Vec::new(),
            fields,
            sfld,
            csum: 0, // Will be calculated by AnkiDroid
            flags: 0,
            data: String::new(),
        }
    }

    /// Create a builder for constructing notes
    pub fn builder(mid: i64) -> NoteBuilder {
        NoteBuilder::new(mid)
    }

    /// Get the first field (key field)
    pub fn key(&self) -> &str {
        self.fields.first().map(|s| s.as_str()).unwrap_or("")
    }
}

/// Builder for creating Note instances
#[derive(Debug)]
pub struct NoteBuilder {
    mid: i64,
    fields: Vec<String>,
    tags: Vec<String>,
}

impl NoteBuilder {
    fn new(mid: i64) -> Self {
        Self {
            mid,
            fields: Vec::new(),
            tags: Vec::new(),
        }
    }

    /// Set the fields for the note
    pub fn fields(mut self, fields: Vec<String>) -> Self {
        self.fields = fields;
        self
    }

    /// Add a single field to the note
    pub fn field(mut self, field: String) -> Self {
        self.fields.push(field);
        self
    }

    /// Set the tags for the note
    pub fn tags(mut self, tags: Vec<String>) -> Self {
        self.tags = tags;
        self
    }

    /// Add a single tag to the note
    pub fn tag(mut self, tag: String) -> Self {
        self.tags.push(tag);
        self
    }

    /// Build the note
    pub fn build(self) -> Note {
        let mut note = Note::new(self.mid, self.fields);
        note.tags = self.tags;
        note
    }
}

/// Represents a card in AnkiDroid
///
/// Cards are generated from notes and represent the actual review items.
/// Each card has a question and answer derived from the note's fields.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Card {
    /// ID of the note this card belongs to
    pub note_id: i64,
    /// Ordinal position of this card template
    pub ord: i32,
    /// Name of the card (from card template)
    pub name: String,
    /// ID of the deck this card belongs to
    pub deck_id: i64,
    /// Question text (formatted HTML)
    pub question: String,
    /// Answer text (formatted HTML)
    pub answer: String,
    /// Simplified question text
    pub question_simple: String,
    /// Simplified answer text
    pub answer_simple: String,
    /// Pure answer text (no formatting)
    pub answer_pure: String,
}

impl Card {
    /// Create a new card
    pub fn new(note_id: i64, ord: i32, deck_id: i64) -> Self {
        Self {
            note_id,
            ord,
            name: String::new(),
            deck_id,
            question: String::new(),
            answer: String::new(),
            question_simple: String::new(),
            answer_simple: String::new(),
            answer_pure: String::new(),
        }
    }
}

/// Represents a deck in AnkiDroid
///
/// Decks are containers for cards and provide organization and study options.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Deck {
    /// Unique identifier for the deck
    pub id: i64,
    /// Display name of the deck
    pub name: String,
    /// Description of the deck
    pub desc: String,
    /// Card counts: [learn, review, new]
    pub counts: Vec<i32>,
    /// Deck configuration options
    pub options: serde_json::Value,
    /// Whether this is a filtered (dynamic) deck
    pub dyn_: bool,
}

impl Deck {
    /// Create a new deck
    pub fn new(id: i64, name: String) -> Self {
        Self {
            id,
            name,
            desc: String::new(),
            counts: vec![0, 0, 0], // [learn, review, new]
            options: serde_json::Value::Object(serde_json::Map::new()),
            dyn_: false,
        }
    }

    /// Get the total number of cards in this deck
    pub fn total_cards(&self) -> i32 {
        self.counts.iter().sum()
    }

    /// Get the number of new cards
    pub fn new_cards(&self) -> i32 {
        self.counts.get(2).copied().unwrap_or(0)
    }

    /// Get the number of learning cards
    pub fn learning_cards(&self) -> i32 {
        self.counts.first().copied().unwrap_or(0)
    }

    /// Get the number of review cards
    pub fn review_cards(&self) -> i32 {
        self.counts.get(1).copied().unwrap_or(0)
    }
}

/// Represents a note type (model) in AnkiDroid
///
/// Models define the structure of notes, including fields and card templates.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Model {
    /// Unique identifier for the model
    pub id: i64,
    /// Display name of the model
    pub name: String,
    /// Names of fields in this model
    pub field_names: Vec<String>,
    /// Number of card templates in this model
    pub num_cards: i32,
    /// CSS styling for cards
    pub css: String,
    /// Default deck ID for new cards (optional)
    pub deck_id: Option<i64>,
    /// Index of the field used for sorting
    pub sort_field_index: i32,
    /// Model type (0 = standard, 1 = cloze)
    pub type_: i32,
    /// LaTeX preamble
    pub latex_pre: String,
    /// LaTeX postamble
    pub latex_post: String,
}

impl Model {
    /// Create a new model
    pub fn new(id: i64, name: String, field_names: Vec<String>) -> Self {
        Self {
            id,
            name,
            num_cards: 1,
            field_names,
            css: String::new(),
            deck_id: None,
            sort_field_index: 0,
            type_: 0, // Standard model
            latex_pre: String::new(),
            latex_post: String::new(),
        }
    }

    /// Check if this is a cloze model
    pub fn is_cloze(&self) -> bool {
        self.type_ == 1
    }

    /// Get the number of fields in this model
    pub fn field_count(&self) -> usize {
        self.field_names.len()
    }
}

/// Simplified note information for API compatibility
///
/// This matches the NoteInfo class from the Kotlin API and provides
/// a subset of note data commonly used in API operations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NoteInfo {
    /// Note ID
    pub id: i64,
    /// Field values
    pub fields: Vec<String>,
    /// Tags associated with the note
    pub tags: Vec<String>,
}

impl NoteInfo {
    /// Create a new NoteInfo
    pub fn new(id: i64, fields: Vec<String>, tags: Vec<String>) -> Self {
        Self { id, fields, tags }
    }

    /// Get the key field (first field)
    pub fn key(&self) -> &str {
        self.fields.first().map(|s| s.as_str()).unwrap_or("")
    }
}

impl From<Note> for NoteInfo {
    fn from(note: Note) -> Self {
        Self {
            id: note.id,
            fields: note.fields,
            tags: note.tags,
        }
    }
}

/// Answer ease levels for card review
///
/// These correspond to the difficulty buttons shown during review.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[repr(i32)]
pub enum Ease {
    /// Again (failure)
    Ease1 = 1,
    /// Hard
    Ease2 = 2,
    /// Good
    Ease3 = 3,
    /// Easy
    Ease4 = 4,
}

impl Ease {
    /// Convert from integer value
    pub fn from_value(value: i32) -> Option<Self> {
        match value {
            1 => Some(Ease::Ease1),
            2 => Some(Ease::Ease2),
            3 => Some(Ease::Ease3),
            4 => Some(Ease::Ease4),
            _ => None,
        }
    }

    /// Get the integer value
    pub fn value(&self) -> i32 {
        *self as i32
    }
}

/// Constants and templates for the basic note type
#[derive(Debug)]
pub struct BasicModel;

impl BasicModel {
    /// Field names for basic model
    pub const FIELDS: &'static [&'static str] = &["Front", "Back"];
    
    /// Card names for basic model
    pub const CARD_NAMES: &'static [&'static str] = &["Card 1"];
    
    /// Question format template
    pub const QFMT: &'static [&'static str] = &["{{Front}}"];
    
    /// Answer format template
    pub const AFMT: &'static [&'static str] = &[
        "{{FrontSide}}\n\n<hr id=\"answer\">\n\n{{Back}}"
    ];
}

/// Constants and templates for the basic with reverse note type
#[derive(Debug)]
pub struct Basic2Model;

impl Basic2Model {
    /// Field names for basic with reverse model
    pub const FIELDS: &'static [&'static str] = &["Front", "Back"];
    
    /// Card names for basic with reverse model
    pub const CARD_NAMES: &'static [&'static str] = &["Card 1", "Card 2"];
    
    /// Question format templates
    pub const QFMT: &'static [&'static str] = &["{{Front}}", "{{Back}}"];
    
    /// Answer format templates
    pub const AFMT: &'static [&'static str] = &[
        "{{FrontSide}}\n\n<hr id=\"answer\">\n\n{{Back}}",
        "{{FrontSide}}\n\n<hr id=\"answer\">\n\n{{Front}}"
    ];
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_note_builder() {
        let note = Note::builder(123)
            .fields(vec!["Front text".to_string(), "Back text".to_string()])
            .tags(vec!["tag1".to_string(), "tag2".to_string()])
            .build();

        assert_eq!(note.mid, 123);
        assert_eq!(note.fields.len(), 2);
        assert_eq!(note.tags.len(), 2);
        assert_eq!(note.key(), "Front text");
    }

    #[test]
    fn test_ease_conversion() {
        assert_eq!(Ease::from_value(1), Some(Ease::Ease1));
        assert_eq!(Ease::from_value(4), Some(Ease::Ease4));
        assert_eq!(Ease::from_value(5), None);
        
        assert_eq!(Ease::Ease3.value(), 3);
    }

    #[test]
    fn test_deck_counts() {
        let deck = Deck {
            id: 1,
            name: "Test Deck".to_string(),
            desc: String::new(),
            counts: vec![5, 10, 15], // [learn, review, new]
            options: serde_json::Value::Object(serde_json::Map::new()),
            dyn_: false,
        };

        assert_eq!(deck.learning_cards(), 5);
        assert_eq!(deck.review_cards(), 10);
        assert_eq!(deck.new_cards(), 15);
        assert_eq!(deck.total_cards(), 30);
    }

    #[test]
    fn test_model_properties() {
        let model = Model::new(
            456,
            "Test Model".to_string(),
            vec!["Field1".to_string(), "Field2".to_string()]
        );

        assert_eq!(model.field_count(), 2);
        assert!(!model.is_cloze());
    }

    #[test]
    fn test_note_info_from_note() {
        let note = Note::builder(789)
            .fields(vec!["Q".to_string(), "A".to_string()])
            .tags(vec!["test".to_string()])
            .build();

        let note_info: NoteInfo = note.into();
        assert_eq!(note_info.key(), "Q");
        assert_eq!(note_info.fields.len(), 2);
        assert_eq!(note_info.tags.len(), 1);
    }

    #[test]
    fn test_basic_model_constants() {
        assert_eq!(BasicModel::FIELDS, &["Front", "Back"]);
        assert_eq!(BasicModel::CARD_NAMES, &["Card 1"]);
        assert_eq!(BasicModel::QFMT.len(), 1);
        assert_eq!(BasicModel::AFMT.len(), 1);
    }

    #[test]
    fn test_basic2_model_constants() {
        assert_eq!(Basic2Model::FIELDS, &["Front", "Back"]);
        assert_eq!(Basic2Model::CARD_NAMES, &["Card 1", "Card 2"]);
        assert_eq!(Basic2Model::QFMT.len(), 2);
        assert_eq!(Basic2Model::AFMT.len(), 2);
    }
}